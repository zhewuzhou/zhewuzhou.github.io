<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>数据库索引数据结构总结 - Studying & Blogging</title><meta name=Description content="Keep Moving, Keep Learning"><meta property="og:title" content="数据库索引数据结构总结"><meta property="og:description" content="摘要 数据库索引是数据库中最重要的组成部分，而索引的数据结构设计对数据库的性能有重要的影响。本文尝试选取几种典型的索引数据结构，总结分析，以窥数据库索引之全貌。
B+Tree B+Tree 是一种树数据结构，是一个n叉排序树，每个节点通常有多个孩子，一棵B+Tree包含根节点、内部节点和叶子节点。根节点可能是一个叶子节点，也可能是一个包含两个或两个以上孩子节点的节点。
B+Tree 几乎是数据库默认的索引实现，其细节如下：
 维基百科在 B+ 树中的节点通常被表示为一组有序的元素和子指针。如果此B+树的序数（order）是m ，则除了根之外的每个节点都包含最少$ {\displaystyle \lfloor m/2\rfloor } \lfloor m/2\rfloor$ 个元素最多 m-1 个元素，对于任意的节点有最多 m 个子指针。对于所有内部节点，子指针的数目总是比元素的数目多一个。因为所有叶子都在相同的高度上，节点通常不包含确定它们是叶子还是内部节点的方式。 每个内部节点的元素充当分开它的子树的分离值。例如，如果内部节点有三个子节点（或子树）则它必须有两个分离值或元素 a1 和 a2。在最左子树中所有的值都小于等于 a1，在中间子树中所有的值都在 a1 和 a2 之间((a1，a2]），而在最右子树中所有的值都大于 a2。
 B+Tree 有如下性质：
 查询时间复杂度为 $O(\log _{m}n)$ 插入时间复杂度 $O(\log _{m}n)$ 删除时间复杂度 $O(\log _{m}n)$ 搜索一个范围的键（k 个键）时间复杂度为 ${\displaystyle O(\log _{m}n+k)}$  B+ Tree 的多线程同步  **搜索：**从根节点开始，获取子节点的读闩，然后释放父节点的读闩；重复这个过程，直到找到目标节点位置。 **插入/删除：**从根节点开始，获取子节点的写闩；重复这个过程，直到找到目标节点位置；如果子节点是安全的，插入/删除不会引起树结构的变化即父节点不需要调整，可释放所有祖先写闩；乐观的插入/删除是先走搜索获得目标节点的读闩，如果目标节点并不安全，则回归上述从根节点获得写闩的过程。  Skip List（跳表） Skip List是一种随机化的数据结构，基于并联的链表，其效率可比拟于二叉查找树（对于大多数操作需要O(log n)平均时间）。基本上，跳跃列表是对有序的链表增加上附加的前进链接，增加是以随机化的方式进行的，所以在列表中的查找可以快速的跳过部分列表(因此得名)。所有操作都以对数随机化的时间进行。Skip List可以很好解决有序链表查找特定值的困难。
一个跳表，应该具有以下特征：
 一个跳表应该有几个层（level）组成； 跳表的第一层包含所有的元素； 每一层都是一个有序的链表； 如果元素x出现在第i层，则所有比i小的层都包含x； 第i层的元素通过一个down指针指向下一层拥有相同值的元素； 在每一层中，-1和1两个元素都出现(分别表示INT_MIN和INT_MAX)； Top指针指向最高层的第一个元素。  相对于 B+Tree，Skip List 有如下优势："><meta property="og:type" content="article"><meta property="og:url" content="https://zhewuzhou.github.io/posts/database-indexes/"><meta property="og:image" content="https://zhewuzhou.github.io/logo.png"><meta property="article:published_time" content="2018-10-18T00:00:00+00:00"><meta property="article:modified_time" content="2020-12-13T22:11:36+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zhewuzhou.github.io/logo.png"><meta name=twitter:title content="数据库索引数据结构总结"><meta name=twitter:description content="摘要 数据库索引是数据库中最重要的组成部分，而索引的数据结构设计对数据库的性能有重要的影响。本文尝试选取几种典型的索引数据结构，总结分析，以窥数据库索引之全貌。
B+Tree B+Tree 是一种树数据结构，是一个n叉排序树，每个节点通常有多个孩子，一棵B+Tree包含根节点、内部节点和叶子节点。根节点可能是一个叶子节点，也可能是一个包含两个或两个以上孩子节点的节点。
B+Tree 几乎是数据库默认的索引实现，其细节如下：
 维基百科在 B+ 树中的节点通常被表示为一组有序的元素和子指针。如果此B+树的序数（order）是m ，则除了根之外的每个节点都包含最少$ {\displaystyle \lfloor m/2\rfloor } \lfloor m/2\rfloor$ 个元素最多 m-1 个元素，对于任意的节点有最多 m 个子指针。对于所有内部节点，子指针的数目总是比元素的数目多一个。因为所有叶子都在相同的高度上，节点通常不包含确定它们是叶子还是内部节点的方式。 每个内部节点的元素充当分开它的子树的分离值。例如，如果内部节点有三个子节点（或子树）则它必须有两个分离值或元素 a1 和 a2。在最左子树中所有的值都小于等于 a1，在中间子树中所有的值都在 a1 和 a2 之间((a1，a2]），而在最右子树中所有的值都大于 a2。
 B+Tree 有如下性质：
 查询时间复杂度为 $O(\log _{m}n)$ 插入时间复杂度 $O(\log _{m}n)$ 删除时间复杂度 $O(\log _{m}n)$ 搜索一个范围的键（k 个键）时间复杂度为 ${\displaystyle O(\log _{m}n+k)}$  B+ Tree 的多线程同步  **搜索：**从根节点开始，获取子节点的读闩，然后释放父节点的读闩；重复这个过程，直到找到目标节点位置。 **插入/删除：**从根节点开始，获取子节点的写闩；重复这个过程，直到找到目标节点位置；如果子节点是安全的，插入/删除不会引起树结构的变化即父节点不需要调整，可释放所有祖先写闩；乐观的插入/删除是先走搜索获得目标节点的读闩，如果目标节点并不安全，则回归上述从根节点获得写闩的过程。  Skip List（跳表） Skip List是一种随机化的数据结构，基于并联的链表，其效率可比拟于二叉查找树（对于大多数操作需要O(log n)平均时间）。基本上，跳跃列表是对有序的链表增加上附加的前进链接，增加是以随机化的方式进行的，所以在列表中的查找可以快速的跳过部分列表(因此得名)。所有操作都以对数随机化的时间进行。Skip List可以很好解决有序链表查找特定值的困难。
一个跳表，应该具有以下特征：
 一个跳表应该有几个层（level）组成； 跳表的第一层包含所有的元素； 每一层都是一个有序的链表； 如果元素x出现在第i层，则所有比i小的层都包含x； 第i层的元素通过一个down指针指向下一层拥有相同值的元素； 在每一层中，-1和1两个元素都出现(分别表示INT_MIN和INT_MAX)； Top指针指向最高层的第一个元素。  相对于 B+Tree，Skip List 有如下优势："><meta name=application-name content="Studying & Blogging"><meta name=apple-mobile-web-app-title content="Studying & Blogging"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://zhewuzhou.github.io/posts/database-indexes/><link rel=prev href=https://zhewuzhou.github.io/posts/weekly-paper-an-empirical-evalution-of-in-memory-mvcc/><link rel=next href=https://zhewuzhou.github.io/posts/weekly-paper-bridging-the-archipelago-between-row-stores-column-stores-hybrid-workloads/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"数据库索引数据结构总结","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/zhewuzhou.github.io\/posts\/database-indexes\/"},"genre":"posts","keywords":"Skiplist, Bw-Tree, Adaptive Radix Tree, Masstree, B\u002bTree, 索引, 无锁","wordcount":245,"url":"https:\/\/zhewuzhou.github.io\/posts\/database-indexes\/","datePublished":"2018-10-18T00:00:00+00:00","dateModified":"2020-12-13T22:11:36+08:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"zhewuzhou"},"author":{"@type":"Person","name":"zhewuzhou"},"description":""}</script></head><body header-desktop=fixed header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':('auto'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'auto'==='dark'))&&document.body.setAttribute('theme','dark');</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="Studying & Blogging"><span class=header-title-pre><i class="far fa-kiss-wink-heart fa-fw"></i></span>zhewu's blog</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/ title=GitHub><i class="fab fa-github fa-fw"></i></a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw"></i></a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw"></i></a><span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin"></i></span></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="Studying & Blogging"><span class=header-title-pre><i class="far fa-kiss-wink-heart fa-fw"></i></span>zhewu's blog</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw"></i></a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw"></i></a><span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin"></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/posts/>文章</a><a class=menu-item href=/tags/>标签</a><a class=menu-item href=/categories/>分类</a><a class=menu-item href=/ title=GitHub><i class="fab fa-github fa-fw"></i></a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class="toc-content always-active" id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animated flipInX">数据库索引数据结构总结</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw"></i>zhewuzhou</a></span>&nbsp;<span class=post-category>收录于 <a href=/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/><i class="far fa-folder fa-fw"></i>数据库</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2018-10-18>2018-10-18</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 245 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 2 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><ul><li><a href=#摘要>摘要</a></li><li><a href=#btree>B+Tree</a><ul><li><a href=#b-tree-的多线程同步>B+ Tree 的多线程同步</a></li></ul></li><li><a href=#skip-list跳表>Skip List（跳表）</a></li><li><a href=#bw-tree5><a href=https://15721.courses.cs.cmu.edu/spring2018/papers/08-oltpindexes1/bwtree-icde2013.pdf>Bw-Tree</a></a></li><li><a href=#adaptive-radix-tree自适应基数前缀树art>Adaptive Radix Tree（自适应基数/前缀树，ART）</a></li><li><a href=#masstree>Masstree</a></li><li><a href=#性能对比>性能对比</a></li><li><a href=#作者的其他数据库文章链接>作者的其他数据库文章链接</a></li></ul></li></ul></nav></div></div><div class=content id=content><h2 id=摘要>摘要</h2><p>数据库索引是数据库中最重要的组成部分，而索引的数据结构设计对数据库的性能有重要的影响。本文尝试选取几种典型的索引数据结构，总结分析，以窥数据库索引之全貌。</p><h2 id=btree>B+Tree</h2><p>B+Tree 是一种树数据结构，是一个n叉排序树，每个节点通常有多个孩子，一棵B+Tree包含根节点、内部节点和叶子节点。根节点可能是一个叶子节点，也可能是一个包含两个或两个以上孩子节点的节点。</p><p>B+Tree 几乎是数据库默认的索引实现，其细节如下：</p><blockquote><p><a href=https://en.wikipedia.org/wiki/B-tree target=_blank rel="noopener noreffer">维基百科</a>在 B+ 树中的节点通常被表示为一组有序的元素和子指针。如果此B+树的序数（order）是m ，则除了根之外的每个节点都包含最少$ {\displaystyle \lfloor m/2\rfloor } \lfloor m/2\rfloor$ 个元素最多 m-1 个元素，对于任意的节点有最多 m 个子指针。对于所有内部节点，子指针的数目总是比元素的数目多一个。因为所有叶子都在相同的高度上，节点通常不包含确定它们是叶子还是内部节点的方式。
每个内部节点的元素充当分开它的子树的分离值。例如，如果内部节点有三个子节点（或子树）则它必须有两个分离值或元素 a1 和 a2。在最左子树中所有的值都小于等于 a1，在中间子树中所有的值都在 a1 和 a2 之间((a1，a2]），而在最右子树中所有的值都大于 a2。</p></blockquote><p><img class=lazyload src=/svg/loading.min.svg data-src=https://blog-image-1258275666.cos.ap-chengdu.myqcloud.com/B+_Tree.png data-srcset="https://blog-image-1258275666.cos.ap-chengdu.myqcloud.com/B+_Tree.png, https://blog-image-1258275666.cos.ap-chengdu.myqcloud.com/B+_Tree.png 1.5x, https://blog-image-1258275666.cos.ap-chengdu.myqcloud.com/B+_Tree.png 2x" data-sizes=auto alt=https://blog-image-1258275666.cos.ap-chengdu.myqcloud.com/B+_Tree.png title=B+Tree></p><p>B+Tree 有如下性质：</p><ol><li>查询时间复杂度为 $O(\log _{m}n)$</li><li>插入时间复杂度 $O(\log _{m}n)$</li><li>删除时间复杂度 $O(\log _{m}n)$</li><li>搜索一个范围的键（k 个键）时间复杂度为 ${\displaystyle O(\log _{m}n+k)}$</li></ol><h3 id=b-tree-的多线程同步>B+ Tree 的多线程同步</h3><ul><li>**搜索：**从根节点开始，获取子节点的读闩，然后释放父节点的读闩；重复这个过程，直到找到目标节点位置。</li><li>**插入/删除：**从根节点开始，获取子节点的写闩；重复这个过程，直到找到目标节点位置；如果子节点是安全的，插入/删除不会引起树结构的变化即父节点不需要调整，可释放所有祖先写闩；乐观的插入/删除是先走搜索获得目标节点的读闩，如果目标节点并不安全，则回归上述从根节点获得写闩的过程。</li></ul><h2 id=skip-list跳表>Skip List（跳表）</h2><p>Skip List是一种随机化的数据结构，基于并联的链表，其效率可比拟于二叉查找树（对于大多数操作需要O(log n)平均时间）。基本上，跳跃列表是对有序的链表增加上附加的前进链接，增加是以随机化的方式进行的，所以在列表中的查找可以快速的跳过部分列表(因此得名)。所有操作都以对数随机化的时间进行。Skip List可以很好解决有序链表查找特定值的困难。</p><p>一个跳表，应该具有以下特征：</p><ol><li>一个跳表应该有几个层（level）组成；</li><li>跳表的第一层包含所有的元素；</li><li>每一层都是一个有序的链表；</li><li>如果元素x出现在第i层，则所有比i小的层都包含x；</li><li>第i层的元素通过一个down指针指向下一层拥有相同值的元素；</li><li>在每一层中，-1和1两个元素都出现(分别表示INT_MIN和INT_MAX)；</li><li>Top指针指向最高层的第一个元素。</li></ol><p>相对于 B+Tree，Skip List 有如下优势：</p><ul><li>B+ Tree 的插入删除操作有可能会引起树结构的变化，需要从新平衡；与之相对的，跳表插入要简单的多，更加简单高效。</li><li>B+ Tree 的实现诸如保持树平衡非常复杂；与之相对的，跳表并没有非常复杂的逻辑，实现相对更加简单。</li><li>取下一个元素可以再常数时间内，相对于 B+ Tree 的对数时间。</li><li>因为链表非常简单，可以很容易的修改跳表结构，以更好地支持诸如范围索引之类的操作。</li><li>链表结构使得多线程修改可以仅用 CAS 保证原子性，从而避免重量级的同步机制。</li><li>链表的持久化更加简单。</li></ul><p><img class=lazyload src=/svg/loading.min.svg data-src=https://blog-image-1258275666.cos.ap-chengdu.myqcloud.com/Skip-List-Layout.png data-srcset="https://blog-image-1258275666.cos.ap-chengdu.myqcloud.com/Skip-List-Layout.png, https://blog-image-1258275666.cos.ap-chengdu.myqcloud.com/Skip-List-Layout.png 1.5x, https://blog-image-1258275666.cos.ap-chengdu.myqcloud.com/Skip-List-Layout.png 2x" data-sizes=auto alt=https://blog-image-1258275666.cos.ap-chengdu.myqcloud.com/Skip-List-Layout.png title="Skip List Layout"></p><p>跳表看起来非常像树，比如说检索
<img class=lazyload src=/svg/loading.min.svg data-src=https://blog-image-1258275666.cos.ap-chengdu.myqcloud.com/Skip-List-Search.png data-srcset="https://blog-image-1258275666.cos.ap-chengdu.myqcloud.com/Skip-List-Search.png, https://blog-image-1258275666.cos.ap-chengdu.myqcloud.com/Skip-List-Search.png 1.5x, https://blog-image-1258275666.cos.ap-chengdu.myqcloud.com/Skip-List-Search.png 2x" data-sizes=auto alt=https://blog-image-1258275666.cos.ap-chengdu.myqcloud.com/Skip-List-Search.png title=Search></p><p>跳表横向看来是有很多链表组成，然而指针跳转对于 <a href=http://ticki.github.io/blog/skip-lists-done-right/ target=_blank rel="noopener noreffer">CPU 缓存</a> 来讲非常不友好，可以用纵向数组来实现跳表以增加 CPU 缓存。
<img class=lazyload src=/svg/loading.min.svg data-src=https://blog-image-1258275666.cos.ap-chengdu.myqcloud.com/Skip-List-Array.png data-srcset="https://blog-image-1258275666.cos.ap-chengdu.myqcloud.com/Skip-List-Array.png, https://blog-image-1258275666.cos.ap-chengdu.myqcloud.com/Skip-List-Array.png 1.5x, https://blog-image-1258275666.cos.ap-chengdu.myqcloud.com/Skip-List-Array.png 2x" data-sizes=auto alt=https://blog-image-1258275666.cos.ap-chengdu.myqcloud.com/Skip-List-Array.png title="Array Skip List"></p><h2 id=bw-tree5><a href=https://15721.courses.cs.cmu.edu/spring2018/papers/08-oltpindexes1/bwtree-icde2013.pdf target=_blank rel="noopener noreffer">Bw-Tree</a></h2><p>Hekaton 是微软 SQLServer 专门针对 OLTP 应用场景进行优化的数据库引擎，其索引实现基于 Bw-Tree。Bw-Tree 是一种无需使用任何闩同步的 B+Tree，其主要设计思想如下：</p><ol><li><strong>Mapping Table（映射表）</strong> 映射表存储内存页的ID与其对应的物理内存地址，使得线程可以通过访问映射表找到需要方位的内存地址，映射表的更新通过CAS操作。</li><li><strong>不直接修改节点</strong>，任何的更新操作都会生成新的数据并通过指针指向被更新节点；新生成的数据所导致的元数据的修改，比如修改映射表都通过 CAS 完成。</li><li><strong>垃圾回收</strong>，Bw-Tree 通过不断新增数据的方式避免直接修改树节点，在树不断更新的过程中，不可避免的会产生很多垃圾，因此 Bw-Tree 实现了基于 Epoch 的垃圾回收机制：当一个线程想保护一个它正在使用但是将会被回收的对象，例如检索的时候，访问了一个内存页，就把当前线程加入 Epoch，当这个线程完成检索页面的操作后，就会退出 Epoch。通常一个线程在一个epoch的时间间隔内完成一次操作，例如检索。在线程成功加入 Epoch 的时候，可能会看到将要被释放的老版本的对象，但不可能看到已经在前一个 Epoch 中释放的对象，因为其在当前 Epoch 中的操作并不依赖上一个 Epoch 中的数据。因此，一旦所有的线程成功加入Epoch 并完成操作然后退出这个Epoch，回收该 Epoch 中的所有对象是安全的。</li></ol><p>由于维护了映射表，和新增数据链，因此树结构调整相对复杂，不仅仅要调整树，切要保证树结构和映射表之间的关系。具体操作可参考<a href=https://zhuanlan.zhihu.com/p/29314464 target=_blank rel="noopener noreffer">此篇文章</a>。</p><p>尽管实现非常复杂，Bw-Tree 作为无锁的数据库索引树，有如下优势：</p><ul><li><strong>无闩</strong>: 实现无锁数据结构十分困难，Bw-Tree 在多线程场景下没有引入任何的闩，只使用 CAS 指令保证线程同步，因此多核的扩展性优于普通用闩同步的B+Tree。</li><li><strong>CPU 缓存</strong>： 由于不直接修改节点而是追加修改补丁，因此 CPU 缓存不会应为更新数据而失效，因此可以显著提高 CPU 缓存命中率。<a href=https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/bw-tree-icde2013-final.pdf target=_blank rel="noopener noreffer">微软论文</a>中的数据表明，90% 的读操作数据来自 CPU L1/L2 缓存。</li></ul><p><img class=lazyload src=/svg/loading.min.svg data-src=https://blog-image-1258275666.cos.ap-chengdu.myqcloud.com/Bw-Tree.png data-srcset="https://blog-image-1258275666.cos.ap-chengdu.myqcloud.com/Bw-Tree.png, https://blog-image-1258275666.cos.ap-chengdu.myqcloud.com/Bw-Tree.png 1.5x, https://blog-image-1258275666.cos.ap-chengdu.myqcloud.com/Bw-Tree.png 2x" data-sizes=auto alt=https://blog-image-1258275666.cos.ap-chengdu.myqcloud.com/Bw-Tree.png title=Bw-Tree></p><h2 id=adaptive-radix-tree自适应基数前缀树art>Adaptive Radix Tree（自适应基数/前缀树，ART）</h2><p>Radix Tree （基数树)是一种常见的前缀树，Linux Kernel 文件系统就用到了该数据结构：
<img class=lazyload src=/svg/loading.min.svg data-src=https://blog-image-1258275666.cos.ap-chengdu.myqcloud.com/Redix-Tree.png data-srcset="https://blog-image-1258275666.cos.ap-chengdu.myqcloud.com/Redix-Tree.png, https://blog-image-1258275666.cos.ap-chengdu.myqcloud.com/Redix-Tree.png 1.5x, https://blog-image-1258275666.cos.ap-chengdu.myqcloud.com/Redix-Tree.png 2x" data-sizes=auto alt=https://blog-image-1258275666.cos.ap-chengdu.myqcloud.com/Redix-Tree.png title="Radix Tree"></p><p>[]Hyper 数据库]<a href=https://15721.courses.cs.cmu.edu/spring2018/papers/09-oltpindexes2/leis-icde2013.pdf target=_blank rel="noopener noreffer">3</a>中实现了 Adaptive Radix Tree （自适应基数/前缀树，ART）作为其索引。基数树的每个节点可以存储任意长度的键切片，比如 Linux Kernel 中的基数树每个节点存储 6位的键切片；然而数据库索引很多场景下会被频繁修改，每个节点固定长度的键切片会造成时间（切片过长）和空间上（切片过短）的浪费，因此，Hyper 实现了自适应的基数树，也就是节点根据长度的不同分成若干种，随着数据的变化而自行调整。</p><p>ART 结构：
<img class=lazyload src=/svg/loading.min.svg data-src=https://blog-image-1258275666.cos.ap-chengdu.myqcloud.com/ART-Layout.png data-srcset="https://blog-image-1258275666.cos.ap-chengdu.myqcloud.com/ART-Layout.png, https://blog-image-1258275666.cos.ap-chengdu.myqcloud.com/ART-Layout.png 1.5x, https://blog-image-1258275666.cos.ap-chengdu.myqcloud.com/ART-Layout.png 2x" data-sizes=auto alt=https://blog-image-1258275666.cos.ap-chengdu.myqcloud.com/ART-Layout.png title=ART></p><p>ART 数据节点类型：
<img class=lazyload src=/svg/loading.min.svg data-src=https://blog-image-1258275666.cos.ap-chengdu.myqcloud.com/ART-Node-Type.png data-srcset="https://blog-image-1258275666.cos.ap-chengdu.myqcloud.com/ART-Node-Type.png, https://blog-image-1258275666.cos.ap-chengdu.myqcloud.com/ART-Node-Type.png 1.5x, https://blog-image-1258275666.cos.ap-chengdu.myqcloud.com/ART-Node-Type.png 2x" data-sizes=auto alt=https://blog-image-1258275666.cos.ap-chengdu.myqcloud.com/ART-Node-Type.png title="Node Types"></p><p>其主要特点有：</p><ul><li>树的高度仅取决于键长度。</li><li>更新和删除不涉及到树结构的调整，不需要平衡操作。</li><li>到达叶子节点的路径就是键。</li><li>时间复杂度取决于键的长度，而跟数据量无关，如果数据的增加远远超过键长度的增加，那么使用 ART 将会在性能上带来非常大的收益。</li></ul><p><a href=https://15721.courses.cs.cmu.edu/spring2018/papers/09-oltpindexes2/leis-damon2016.pdf target=_blank rel="noopener noreffer">讲述ART同步的论文</a>中提供了描述了两种ART的同步机制：</p><ol><li>乐观锁：<ul><li>读不阻塞写</li><li>写操作在获得对应的节点闩之后，更新版本信息</li><li>读操作在读下一个结点前，检查版本信息是否发生改变</li></ul></li><li>乐观读悲观写<ul><li>所有的节点都包含一个互斥锁，当某一个读操作获得此互斥锁之后，阻塞其他写操作</li><li>读操作不用获取任何的锁或者闩，也不用检查版本信息</li><li>写操作保证同一个节点读操作的数据一致性，即写操作使用原子指令进行写入</li></ul></li></ol><h2 id=masstree>Masstree</h2><p>2012年发表的论文 <a href=https://pdos.csail.mit.edu/papers/masstree:eurosys12.pdf target=_blank rel="noopener noreffer">Cache craftiness for fast multicore key-value storage</a> 提出了 Masstree，其特点如下：</p><ul><li><strong>可以理解为B+ Tree 和 Radix Tree 的混合体</strong>，即将键切分成多个部分，每个部分为一个节点；每个节点内部又是一个 B+ Tree，兼顾空间和性能。
<img class=lazyload src=/svg/loading.min.svg data-src=https://blog-image-1258275666.cos.ap-chengdu.myqcloud.com/Mass-Tree.png data-srcset="https://blog-image-1258275666.cos.ap-chengdu.myqcloud.com/Mass-Tree.png, https://blog-image-1258275666.cos.ap-chengdu.myqcloud.com/Mass-Tree.png 1.5x, https://blog-image-1258275666.cos.ap-chengdu.myqcloud.com/Mass-Tree.png 2x" data-sizes=auto alt=https://blog-image-1258275666.cos.ap-chengdu.myqcloud.com/Mass-Tree.png title="Mass Tree"></li><li>Masstree将变长键划分成多个固长部分，每个固长部分可以通过int类型表示，而不是char类型。由于处理器处理int类型比较操作的速度远远快于char数组的比较，因此Masstree通过int类型的比较进一步加速了查找过程。固定长度可以设置为 CPU 缓存行长度，以增加 CPU 缓存效率。</li><li>每个节点是一个 B+ Tree，因此 CPU 在查询的时候可以将节点所代表的B+ Tree 加载到 CPU 缓存中，以增加 CPU 缓存命中率。</li><li>其并发控制用到了Read-Copy-Update(RCU)。读不因任何数据更新而阻塞，但更新数据的时候，需要先复制一份副本，在副本上完成修改，再一次性地替换旧数据。因此读不会造成 CPU 缓存无效。</li></ul><h2 id=性能对比>性能对比</h2><p>上述几种索引数据结构<a href=http://www.cs.cmu.edu/~huanche1/publications/open_bwtree.pdf target=_blank rel="noopener noreffer">性能对比</a>如下：
<img class=lazyload src=/svg/loading.min.svg data-src=https://blog-image-1258275666.cos.ap-chengdu.myqcloud.com/Index-Performance.png data-srcset="https://blog-image-1258275666.cos.ap-chengdu.myqcloud.com/Index-Performance.png, https://blog-image-1258275666.cos.ap-chengdu.myqcloud.com/Index-Performance.png 1.5x, https://blog-image-1258275666.cos.ap-chengdu.myqcloud.com/Index-Performance.png 2x" data-sizes=auto alt=https://blog-image-1258275666.cos.ap-chengdu.myqcloud.com/Index-Performance.png title="Indexs Performance"></p><h2 id=作者的其他数据库文章链接>作者的其他数据库文章链接</h2><ol><li><a href=https://zhewuzhou.github.io/2018/08/07/SQL_as_universe_language_in_data_world/ target=_blank rel="noopener noreffer">SQL：数据世界的通用语</a></li><li><a href=https://zhewuzhou.github.io/2018/09/13/SQL_Compilation_Technology_For_Performance/ target=_blank rel="noopener noreffer">数据库性能之翼：SQL 语句运行时编译</a></li><li><a href=https://zhewuzhou.github.io/2018/09/25/Weekly-Paper-A-Survey-of-B-Tree-Locking-Techniques/ target=_blank rel="noopener noreffer">每周一论文：A Survey of B-Tree Locking Techniques</a></li><li><a href=https://zhewuzhou.github.io/2018/09/29/Weekly-Paper-An-Empirical-Evalution-of-In-Memory-MVCC/ target=_blank rel="noopener noreffer">每周一论文：An Empirical Evaluation of In-Memory Multi-Version Concurrency Control</a></li><li><a href=https://zhewuzhou.github.io/2018/10/18/Database-Indexes/ target=_blank rel="noopener noreffer">数据库索引数据结构总结</a></li></ol></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2020-12-13</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md><span><a class=link-to-markdown href=/posts/database-indexes/index.md target=_blank>阅读原始文档</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=https://zhewuzhou.github.io/posts/database-indexes/ data-title=数据库索引数据结构总结 data-hashtags="Skiplist,Bw-Tree,Adaptive Radix Tree,Masstree,B+Tree,索引,无锁"><i class="fab fa-twitter fa-fw"></i></a><a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://zhewuzhou.github.io/posts/database-indexes/ data-hashtag=Skiplist><i class="fab fa-facebook-square fa-fw"></i></a><a href=javascript:void(0); title="分享到 Linkedin" data-sharer=linkedin data-url=https://zhewuzhou.github.io/posts/database-indexes/><i class="fab fa-linkedin fa-fw"></i></a><a href=javascript:void(0); title="分享到 Hacker News" data-sharer=hackernews data-url=https://zhewuzhou.github.io/posts/database-indexes/ data-title=数据库索引数据结构总结><i class="fab fa-hacker-news fa-fw"></i></a><a href=javascript:void(0); title="分享到 Line" data-sharer=line data-url=https://zhewuzhou.github.io/posts/database-indexes/ data-title=数据库索引数据结构总结><i data-svg-src=/lib/simple-icons/icons/line.min.svg></i></a><a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://zhewuzhou.github.io/posts/database-indexes/ data-title=数据库索引数据结构总结><i class="fab fa-weibo fa-fw"></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/skiplist/>Skiplist</a>,&nbsp;<a href=/tags/bw-tree/>Bw-Tree</a>,&nbsp;<a href=/tags/adaptive-radix-tree/>Adaptive Radix Tree</a>,&nbsp;<a href=/tags/masstree/>Masstree</a>,&nbsp;<a href=/tags/b+tree/>B+Tree</a>,&nbsp;<a href=/tags/%E7%B4%A2%E5%BC%95/>索引</a>,&nbsp;<a href=/tags/%E6%97%A0%E9%94%81/>无锁</a></section><section><span><a href=javascript:void(0); onclick=window.history.back();>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/weekly-paper-an-empirical-evalution-of-in-memory-mvcc/ class=prev rel=prev title="每周一论文：An Empirical Evaluation of In-Memory Multi-Version Concurrency Control"><i class="fas fa-angle-left fa-fw"></i>每周一论文：An Empirical Evaluation of In-Memory Multi-Version Concurrency Control</a>
<a href=/posts/weekly-paper-bridging-the-archipelago-between-row-stores-column-stores-hybrid-workloads/ class=next rel=next title="每周一论文：Bridging the Archipelago betweenRow-Stores and Column-Stores for Hybrid Workloads">每周一论文：Bridging the Archipelago betweenRow-Stores and Column-Stores for Hybrid Workloads<i class="fas fa-angle-right fa-fw"></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.79.0">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i>LoveIt</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2020</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank>zhewuzhou</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i></a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><link rel=stylesheet href=/lib/lightgallery/lightgallery.min.css><script type=text/javascript src=/lib/smooth-scroll/smooth-scroll.min.js></script><script type=text/javascript src=/lib/autocomplete/autocomplete.min.js></script><script type=text/javascript src=/lib/algoliasearch/algoliasearch-lite.umd.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/twemoji/twemoji.min.js></script><script type=text/javascript src=/lib/lightgallery/lightgallery.min.js></script><script type=text/javascript src=/lib/lightgallery/lg-thumbnail.min.js></script><script type=text/javascript src=/lib/lightgallery/lg-zoom.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/lib/sharer/sharer.min.js></script><script type=text/javascript>window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{},"lightGallery":{"actualSize":false,"exThumbImage":"data-thumbnail","hideBarsDelay":2000,"selector":".lightgallery","speed":400,"thumbContHeight":80,"thumbWidth":80,"thumbnail":true},"search":{"algoliaAppID":"XNEGAJ4RGK","algoliaIndex":"zhewuzhou.github.io","algoliaSearchKey":"200e37ab4b326abd73ff15c859620520","highlightTag":"em","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"algolia"},"twemoji":true};</script><script type=text/javascript src=/js/theme.min.js></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js',new Date());gtag('config','UA-71202311-1',{'anonymize_ip':true});</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=UA-71202311-1" async></script></body></html>