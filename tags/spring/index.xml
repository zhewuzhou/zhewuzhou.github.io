<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Spring - 标签 - Studying &amp; Blogging</title><link>https://zhewuzhou.github.io/tags/spring/</link><description>Spring - 标签 - Studying &amp; Blogging</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sat, 01 Sep 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://zhewuzhou.github.io/tags/spring/" rel="self" type="application/rss+xml"/><item><title>Spring AOP：内部调用陷阱</title><link>https://zhewuzhou.github.io/posts/spring_aop_trap/</link><pubDate>Sat, 01 Sep 2018 00:00:00 +0000</pubDate><author>作者</author><guid>https://zhewuzhou.github.io/posts/spring_aop_trap/</guid><description>摘要 最近写代码，遇到一个 奇怪的Spring AOP 有关的问题；本文从这个问题出发，通过问问题的方式揭示这个问题背后深层原因。
AOP 问题代码清单 AOP Aspect: HttpHeaderValidator.java 1 2 3 4 5 6 7 @Aspect public class HttpHeaderValidator { @Before public void isUserInfoExist(){ ... } } AOP Joint Point: Logger.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Aspect public class Logger { public void logTransactionA(){ String user = this.getUserFromHeader(); .</description></item></channel></rss>